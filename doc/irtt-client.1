.\"t
.\" Automatically generated by Pandoc 2.1.1
.\"
.TH "IRTT\-CLIENT" "1" "February 4, 2018" "v0.9" "IRTT Manual"
.hy
.SH NAME
.PP
irtt\-client \- Isochronous Round\-Trip Time Client
.SH SYNOPSIS
.PP
irtt client [\f[I]args\f[]]
.SH DESCRIPTION
.PP
IRTT measures round\-trip time and other latency related metrics using
UDP packets sent on a fixed period, and produces both text and JSON
output.
.SH OPTIONS
.TP
.B \-d \f[I]duration\f[]
Total time to send (default 1m0s, see Duration units below)
.RS
.RE
.TP
.B \-i \f[I]interval\f[]
Send interval (default 1s, see Duration units below)
.RS
.RE
.TP
.B \-l \f[I]length\f[]
Length of packet (default 0, increased as necessary for required
headers), common values:
.RS
.IP \[bu] 2
1472 (max unfragmented size of IPv4 datagram for 1500 byte MTU)
.IP \[bu] 2
1452 (max unfragmented size of IPv6 datagram for 1500 byte MTU)
.RE
.TP
.B \-o \f[I]file\f[]
Write JSON output to file (use `\-' for stdout).
The extension used for \f[I]file\f[] controls the gzip behavior as
follows (output to stdout is not gzipped):
.RS
.PP
.TS
tab(@);
l l.
T{
Extension
T}@T{
Behavior
T}
_
T{
none
T}@T{
extension .json.gz is added, output is gzipped
T}
T{
\&.json.gz
T}@T{
output is gzipped
T}
T{
\&.gz
T}@T{
output is gzipped, extension changed to .json.gz
T}
T{
\&.json
T}@T{
output is not gzipped
T}
.TE
.RE
.TP
.B \-q
Quiet, suppress per\-packet output
.RS
.RE
.TP
.B \-Q
Really quiet, suppress all output except errors to stderr
.RS
.RE
.TP
.B \-n
No test, connect to the server and validate test parameters but don't
run the test
.RS
.RE
.TP
.B \-\-stats=\f[I]stats\f[]
Server stats on received packets (default \f[I]both\f[]).
Possible values:
.RS
.PP
.TS
tab(@);
l l.
T{
Value
T}@T{
Meaning
T}
_
T{
\f[I]none\f[]
T}@T{
no server stats on received packets
T}
T{
\f[I]count\f[]
T}@T{
total count of received packets
T}
T{
\f[I]window\f[]
T}@T{
receipt status of last 64 packets with each reply
T}
T{
\f[I]both\f[]
T}@T{
both count and window
T}
.TE
.RE
.TP
.B \-\-tstamp=\f[I]mode\f[]
Server timestamp mode (default \f[I]both\f[]).
Possible values:
.RS
.PP
.TS
tab(@);
l l.
T{
Value
T}@T{
Meaning
T}
_
T{
\f[I]none\f[]
T}@T{
request no timestamps
T}
T{
\f[I]send\f[]
T}@T{
request timestamp at server send
T}
T{
\f[I]receive\f[]
T}@T{
request timestamp at server receive
T}
T{
\f[I]both\f[]
T}@T{
request both send and receive timestamps
T}
T{
\f[I]midpoint\f[]
T}@T{
request midpoint timestamp (send/receive avg)
T}
.TE
.RE
.TP
.B \-\-clock=\f[I]clock\f[]
Clock/s used for server timestamps (default \f[I]both\f[]).
Possible values:
.RS
.PP
.TS
tab(@);
l l.
T{
Value
T}@T{
Meaning
T}
_
T{
\f[I]wall\f[]
T}@T{
wall clock only
T}
T{
\f[I]monotonic\f[]
T}@T{
monotonic clock only
T}
T{
\f[I]both\f[]
T}@T{
both clocks
T}
.TE
.RE
.TP
.B \-\-dscp=\f[I]dscp\f[]
DSCP (ToS) value (default 0, 0x prefix for hex).
Common values:
.RS
.PP
.TS
tab(@);
l l.
T{
Value
T}@T{
Meaning
T}
_
T{
0
T}@T{
Best effort
T}
T{
8
T}@T{
CS1\- Bulk
T}
T{
40
T}@T{
CS5\- Video
T}
T{
46
T}@T{
EF\- Expedited forwarding
T}
.TE
.PP
DSCP & ToS (https://www.tucny.com/Home/dscp-tos)
.RE
.TP
.B \-\-df=\f[I]DF\f[]
Setting for do not fragment (DF) bit in all packets.
Possible values:
.RS
.PP
.TS
tab(@);
l l.
T{
Value
T}@T{
Meaning
T}
_
T{
\f[I]default\f[]
T}@T{
OS default
T}
T{
\f[I]false\f[]
T}@T{
DF bit not set
T}
T{
\f[I]true\f[]
T}@T{
DF bit set
T}
.TE
.RE
.TP
.B \-\-wait=\f[I]wait\f[]
Wait time at end of test for unreceived replies (default 3x4s).
Possible values:
.RS
.PP
.TS
tab(@);
l l.
T{
Format
T}@T{
Meaning
T}
_
T{
#\f[I]x\f[]duration
T}@T{
# times max RTT, or duration if no response
T}
T{
#\f[I]r\f[]duration
T}@T{
# times RTT, or duration if no response
T}
T{
duration
T}@T{
fixed duration (see Duration units below)
T}
.TE
.PP
Examples:
.PP
.TS
tab(@);
l l.
T{
Example
T}@T{
Meaning
T}
_
T{
3x4s
T}@T{
3 times max RTT, or 4 seconds if no response
T}
T{
1500ms
T}@T{
fixed 1500 milliseconds
T}
.TE
.RE
.TP
.B \-\-timer=\f[I]timer\f[]
Timer for waiting to send packets (default comp).
Possible values:
.RS
.PP
.TS
tab(@);
l l.
T{
Value
T}@T{
Meaning
T}
_
T{
\f[I]simple\f[]
T}@T{
Go's standard time.Timer
T}
T{
\f[I]comp\f[]
T}@T{
Simple timer with error compensation (see \-tcomp)
T}
T{
\f[I]hybrid:\f[]#
T}@T{
Hybrid comp/busy timer with sleep factor (default 0.95)
T}
T{
\f[I]busy\f[]
T}@T{
busy wait loop (high precision and CPU, blasphemy)
T}
.TE
.RE
.TP
.B \-\-tcomp=\f[I]alg\f[]
Comp timer averaging algorithm (default exp:0.10).
Possible values:
.RS
.PP
.TS
tab(@);
l l.
T{
Value
T}@T{
Meaning
T}
_
T{
\f[I]avg\f[]
T}@T{
Cumulative average error
T}
T{
\f[I]win:\f[]#
T}@T{
Moving average error with window # (default 5)
T}
T{
\f[I]exp:\f[]#
T}@T{
Exponential average with alpha # (default 0.10)
T}
.TE
.RE
.TP
.B \-\-fill=\f[I]fill\f[]
Fill payload with given data (default none).
Possible values:
.RS
.PP
.TS
tab(@);
l l.
T{
Value
T}@T{
Meaning
T}
_
T{
\f[I]none\f[]
T}@T{
Leave payload as all zeroes
T}
T{
\f[I]rand\f[]
T}@T{
Use random bytes from Go's math.rand
T}
T{
\f[I]pattern:\f[]XX
T}@T{
Use repeating pattern of hex (default 69727474)
T}
.TE
.RE
.TP
.B \-\-fill\-one
Fill only once and repeat for all packets
.RS
.RE
.TP
.B \-\-sfill=fill
Request server fill (default not specified).
See values for \[en]fill.
Server must support and allow this fill with \[en]allow\-fills.
.RS
.RE
.TP
.B \-\-local=addr
Local address (default from OS).
Possible values:
.RS
.PP
.TS
tab(@);
l l.
T{
Value
T}@T{
Meaning
T}
_
T{
\f[I]:port\f[]
T}@T{
Unspecified address (all IPv4/IPv6 addresses) with port
T}
T{
\f[I]host\f[]
T}@T{
Host with dynamic port, see Host formats below
T}
T{
\f[I]host:port\f[]
T}@T{
Host with specified port, see Host formats below
T}
.TE
.RE
.TP
.B \-\-hmac=key
Add HMAC with key (0x for hex) to all packets, provides:
.RS
.IP \[bu] 2
Dropping of all packets without a correct HMAC
.IP \[bu] 2
Protection for server against unauthorized discovery and use
.RE
.TP
.B \-4
IPv4 only
.RS
.RE
.TP
.B \-6
IPv6 only
.RS
.RE
.TP
.B \-\-timeouts=\f[I]durations\f[]
Timeouts used when connecting to server (default 1s,2s,4s,8s).
Comma separated list of durations (see Duration units below).
Total wait time will be up to the sum of these Durations.
Max packets sent is up to the number of Durations.
Minimum timeout duration is 200ms.
.RS
.RE
.TP
.B \-\-ttl=\f[I]ttl\f[]
Time to live (default 0, meaning use OS default)
.RS
.RE
.TP
.B \-\-loose
Accept and use any server restricted test parameters instead of exiting
with nonzero status.
.RS
.RE
.TP
.B \-\-thread
Lock sending and receiving goroutines to OS threads
.RS
.RE
.TP
.B \-h
Show help
.RS
.RE
.TP
.B \-v
Show version
.RS
.RE
.SS Host formats
.PP
Hosts may be either hostnames (for IPv4 or IPv6) or IP addresses.
IPv6 addresses must be surrounded by brackets and may include a zone
after the % character.
Examples:
.PP
.TS
tab(@);
l l.
T{
Type
T}@T{
Example
T}
_
T{
IPv4 IP
T}@T{
192.168.1.10
T}
T{
IPv6 IP
T}@T{
[fe80::426c:8fff:fe13:9feb%en0]
T}
T{
IPv4/6 hostname
T}@T{
localhost
T}
.TE
.PP
\f[B]Note:\f[] IPv6 addresses must be quoted in most shells.
.SS Duration units
.PP
Durations are a sequence of decimal numbers, each with optional
fraction, and unit suffix, such as: \[lq]300ms\[rq], \[lq]1m30s\[rq] or
\[lq]2.5m\[rq].
Sanity not enforced.
.PP
.TS
tab(@);
l l.
T{
Suffix
T}@T{
Unit
T}
_
T{
h
T}@T{
hours
T}
T{
m
T}@T{
minutes
T}
T{
s
T}@T{
seconds
T}
T{
ms
T}@T{
milliseconds
T}
T{
ns
T}@T{
nanoseconds
T}
.TE
.SH OUTPUT
.SH RETURN VALUE
.SH EXAMPLES
.SH SEE ALSO
.PP
irtt(1), irtt\-server(1)
.PP
IRTT GitHub repository (https://github.com/peteheist/irtt/)
